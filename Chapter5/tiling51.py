# Given a 2^n Ã— 2^n checkerboard with one square missing,
# construct a tiling of this checkerboard using right triominoes.
import sys
import numpy as np

def main():
    # Input: Value of n for a checkerboard of size 2^n by 2^n
    n = 3
    # Input: Location of missing square enter x-y coordinate as tuple with top left of board designated as (0,0)
    missing = (5,6)

    # Calculate dimensions of board for chosen value of n
    dim = 2 ** n
    print(f"You have selected a {dim}x{dim} board.")
    # Generate board
    board = [[None for x in range(dim)] for y in range(dim)]
    # Assign letter M to missing square
    board[missing[0]][missing[1]] = "M"
    
    # Initialize variables
    xs = 0          # x starting coordinate
    xe = dim - 1    # x ending coordinate
    ys = 0          # y starting coordinate
    ye = dim - 1     # y ending coordinate
    # Create counter iterator for use during recursion. Each number will correspond to a single right trionimo.
    # In the print out, to determine location of a L-triomino, just locate three of a certain number
    counter = iter(range(dim*dim))

    # Call to tiling
    tiling(board,missing, counter, xs, xe, ys, ye)
    # Print out final results
    print("Final Board:")
    print(np.matrix(board))
    
# Tiling Function: a recursive function that calls itself on the 4 quadrants of the board that was initially input.
# This process continues recursively until it reaches the recursive base case of a 2x2 board, for which tiling 
# with a L-triomino is trivial. 
def tiling(board, missing, counter, xs, xe, ys, ye):
    # diff is the height/width of the board/subboard the function was called on.
    diff = xe + 1 - xs
    half = diff / 2
    
    # The following if statement is for the recursive basecase which is a 2x2 subboard which
    # can be trivially solved.    
    if (diff <= 2):
        # If this "if" statement is entered, you have one of two cases: A)you have a 2x2
        # subboard with an M(missing square) in one of the squares, or B) has a P in one of the squares which 
        # was placed before the recursive calls were made at each recursive step.
        
        # Call function pDomino to determine if there exists a P tile in the 2x2 subboard or the function index_2d
        # will return None if  no P tile exists in 2x2 subboard. A P and a M cannot exists simultaneously on a 2x2
        # subboard
        # pDomino = index_2d(board, "P", xs, xe, ys, ye)
        # Find index and val of non-empty square in 2X2 subboard
        index, val = nonempty(board, xs, xe, ys, ye)
        # Place numbered domino in the three empty tiles of 2X2 board.
        if (val == "M"): # 2x2 subboard has an M in one of the tiles, tile remaining three tiles with a numbered L-omino
            tile2x2(board, missing, counter, xs, xe, ys, ye)
        else: # 2x2 subboard has an int in one of the tiles, tile remaining three tiles with a numbered L-omino
            tile2x2(board, index, counter, xs, xe, ys, ye)
        return    


    
    # Call nonempty() function on this subsection of board. This subsection of the board should only contain 
    # one value, either an int denoting one of the 3 tiles of a numbered L-omino with that number or the 
    # value "M" signifying the missing square.
    index, val = nonempty(board, xs, xe, ys, ye)
    
    if (val == "M"):
        # This branch of the if statement happens, if there was no P tile but the missing tile("M") is in this 
        # subsection of the board. The function pTile() will return the Determine 3 squares to tile with P tile. Function pTile returns array of len 3 of 3-tuples for the P tile
        # coordinates
        pTiles = pTile(xs,xe,ys,ye,half,missing)
        # Generate next number of L-omino to tile the pTiles with.
        num = next(counter)
        for tile in pTiles:
            board[int(tile[0])][int(tile[1])] = num
    else: # Situation where portion of board being analyzed doesnt contain a missing square but a P tile.
        pTiles = pTile(xs,xe,ys,ye,half,index)
        # Generate next number of L-omino to tile the pTiles with.
        num = next(counter)
        for tile in pTiles:
            board[int(tile[0])][int(tile[1])] = num
        
    # Make recursive calls on 4 quadrants of current subboard.    
    tiling(board, missing, counter, xs, (xe - half), ys, (ye - half))
    tiling(board, missing, counter, (xe - half + 1), xe, ys, (ye - half))
    tiling(board, missing, counter, xs, (xe - half), (ye - half + 1), ye)
    tiling(board, missing, counter, (xe - half + 1), xe, (ye - half + 1), ye)


# Function fills 3 empty tiles of 2X2 subboard with a number generated by iterator called counter.
def tile2x2(board, filled, counter, xs, xe, ys, ye):
    # Next dominonumber generated by iterator called counter. This domino number will used to tile 3
    # empty squares in the 2x2 subboard.
    dominonumber = next(counter)
    # Loop through board placing number in the three empty tiles in 2x2 board.
    for i in range(int(xs),int(xe + 1)):
        for j in range(int(ys), int(ye + 1)):
            if ((i != filled[0]) or (j != filled[1])):
                board[i][j] = dominonumber

# Function to search a 2D array between provided x and y endpoints in which there is only one non-None
# value. Function returns the index of that value as a 2-tuple and the value found, or None if no such value 
# was found.
def nonempty(myList, startx, endx, starty, endy):
    for i in range(int(startx), int(endx + 1)):
        for j in range(int(starty),int(endy + 1)):
            if (myList[i][j] != None):
                return (i,j), myList[i][j]
    return None

# The function pTile() will determine 3 squares to tile with a numbered tile before the next step where recursive 
# calls are made on the 4 quadrants of current subboard. Function pTile returns array of len 3 of 3-tuples 
# for the P tile coordinates
def pTile(xs,xe,ys,ye,half,filled):
    if ((filled[0]>= xs) and (filled[0] <= (xe - half)) and (filled[1] >= ys) and (filled[1]<=(ye - half))):
        pTile1 = ((xe - half),(ye - half + 1))
        pTile2 = ((xe - half + 1),(ye - half))
        pTile3 = ((xe - half + 1),(ye - half + 1))
    elif ((filled[0]>= xs) and (filled[0] <= (xe - half)) and (filled[1] >= (ye - half + 1)) and (filled[1]<=(ye))):
        pTile1 = ((xe - half),(ye - half))
        pTile2 = ((xe - half + 1),(ye - half))
        pTile3 = ((xe - half + 1),(ye - half + 1))
    elif ((filled[0]>= (xe - half + 1)) and (filled[0] <= (xe)) and (filled[1] >= (ys)) and (filled[1]<=(ye - half))):
        pTile1 = ((xe - half),(ye - half))
        pTile2 = ((xe - half),(ye - half + 1))
        pTile3 = ((xe - half + 1),(ye - half + 1))
    elif ((filled[0]>= (xe - half + 1)) and (filled[0] <= (xe)) and (filled[1] >= (ye - half + 1)) and (filled[1]<=(ye))):
        pTile1 = ((xe - half),(ye - half))
        pTile2 = ((xe - half),(ye - half + 1))
        pTile3 = ((xe - half + 1),(ye - half))
    return pTile1,pTile2,pTile3


if __name__ == "__main__":
    main()
